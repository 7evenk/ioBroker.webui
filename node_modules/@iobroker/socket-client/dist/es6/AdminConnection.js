import { Connection, ERRORS } from './Connection.js';
import { getObjectViewResultToArray, normalizeHostId, objectIdToHostname, } from './tools.js';
function parseCertificate(name, cert) {
    if (!cert)
        return;
    let type;
    // If it is filename, it could be everything
    if (cert.length < 700 &&
        (cert.indexOf("/") !== -1 || cert.indexOf("\\") !== -1)) {
        if (name.toLowerCase().includes("private")) {
            type = "private";
        }
        else if (cert.toLowerCase().includes("private")) {
            type = "private";
        }
        else if (name.toLowerCase().includes("public")) {
            type = "public";
        }
        else if (cert.toLowerCase().includes("public")) {
            type = "public";
        }
        else {
            // TODO: is this correct?
            return;
        }
    }
    else {
        type =
            cert.substring(0, "-----BEGIN RSA PRIVATE KEY".length) ===
                "-----BEGIN RSA PRIVATE KEY" ||
                cert.substring(0, "-----BEGIN PRIVATE KEY".length) ===
                    "-----BEGIN PRIVATE KEY"
                ? "private"
                : "public";
        if (type === "public") {
            const m = cert.split("-----END CERTIFICATE-----");
            if (m.filter((t) => t.replace(/\r\n|\r|\n/, "").trim()).length > 1) {
                type = "chained";
            }
        }
    }
    return { name, type };
}
function parseIPAddresses(host) {
    const IPs4 = [
        {
            name: "[IPv4] 0.0.0.0 - Listen on all IPs",
            address: "0.0.0.0",
            family: "ipv4",
        },
    ];
    const IPs6 = [
        {
            name: "[IPv6] :: - Listen on all IPs",
            address: "::",
            family: "ipv6",
        },
    ];
    if (host.native?.hardware?.networkInterfaces) {
        for (const [eth, iface] of Object.entries(host.native.hardware.networkInterfaces)) {
            if (!iface)
                continue;
            for (const ip of iface) {
                if (ip.family !== "IPv6") {
                    IPs4.push({
                        name: `[${ip.family}] ${ip.address} - ${eth}`,
                        address: ip.address,
                        family: "ipv4",
                    });
                }
                else {
                    IPs6.push({
                        name: `[${ip.family}] ${ip.address} - ${eth}`,
                        address: ip.address,
                        family: "ipv6",
                    });
                }
            }
        }
    }
    return { IPs4, IPs6 };
}
export class AdminConnection extends Connection {
    constructor(props) {
        super(props);
    }
    // We overload the request method here because the admin connection's methods all have `requireAdmin: true`
    request(options) {
        return super.request({ requireAdmin: true, ...options });
    }
    /**
     * Get the stored certificates.
     * @param update Force update.
     */
    getCertificates(update) {
        return this.request({
            cacheKey: "cert",
            forceUpdate: update,
            // TODO: check if this should time out
            commandTimeout: false,
            executor: async (resolve) => {
                const obj = await this.getObject("system.certificates");
                if (obj?.native?.certificates) {
                    resolve(Object.entries(obj.native.certificates)
                        .map(([name, cert]) => parseCertificate(name, cert))
                        .filter((cert) => !!cert));
                }
                else {
                    resolve([]);
                }
            },
        });
    }
    /**
     * Get the logs from a host (only for admin connection).
     * @param host
     * @param linesNumber
     */
    getLogs(host, linesNumber = 200) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve) => {
                this._socket.emit("sendToHost", host, "getLogs", linesNumber || 200, (lines) => {
                    resolve(lines);
                });
            },
        });
    }
    /**
     * Get the log files (only for admin connection).
     */
    getLogsFiles(host) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("readLogs", host, (err, files) => {
                    if (err)
                        reject(err);
                    resolve(files);
                });
            },
        });
    }
    /**
     * Delete the logs from a host (only for admin connection).
     */
    delLogs(host) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("sendToHost", host, "delLogs", null, (err) => {
                    if (err)
                        reject(err);
                    resolve();
                });
            },
        });
    }
    /**
     * Delete a file of an adapter.
     * @param adapter The adapter name.
     * @param fileName The file name.
     */
    deleteFile(adapter, fileName) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("deleteFile", adapter, fileName, (err) => {
                    if (err)
                        reject(err);
                    resolve();
                });
            },
        });
    }
    /**
     * Delete a folder of an adapter.
     * @param adapter The adapter name.
     * @param folderName The folder name.
     */
    deleteFolder(adapter, folderName) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("deleteFolder", adapter, folderName, (err) => {
                    if (err)
                        reject(err);
                    resolve();
                });
            },
        });
    }
    /**
     * Get the list of all hosts.
     * @param update Force update.
     */
    getHosts(update) {
        return this.request({
            cacheKey: "hosts",
            forceUpdate: update,
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("getObjectView", "system", "host", { startkey: "system.host.", endkey: "system.host.\u9999" }, (err, doc) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(getObjectViewResultToArray(doc));
                    }
                });
            },
        });
    }
    /**
     * Get the list of all users.
     * @param update Force update.
     */
    getUsers(update) {
        return this.request({
            cacheKey: "users",
            forceUpdate: update,
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("getObjectView", "system", "user", { startkey: "system.user.", endkey: "system.user.\u9999" }, (err, doc) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(getObjectViewResultToArray(doc));
                    }
                });
            },
        });
    }
    /**
     * Get the list of all groups.
     * @param update Force update.
     */
    getGroups(update) {
        return this.request({
            cacheKey: "groups",
            forceUpdate: update,
            // TODO: check if this should time out
            commandTimeout: false,
            executor: (resolve, reject) => {
                this._socket.emit("getObjectView", "system", "group", {
                    startkey: "system.group.",
                    endkey: "system.group.\u9999",
                }, (err, doc) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(getObjectViewResultToArray(doc));
                    }
                });
            },
        });
    }
    /**
     * Rename a group.
     * @param id The id.
     * @param newId The new id.
     * @param newName The new name.
     */
    renameGroup(id, newId, newName) {
        return this.request({
            // TODO: check if this should time out
            commandTimeout: false,
            executor: async (resolve) => {
                const groups = await this.getGroups(true);
                // renaming a group happens by re-creating the object under a different ID
                const subGroups = groups.filter((g) => g._id.startsWith(`${id}.`));
                // First do this for all sub groups
                for (const group of subGroups) {
                    const oldGroupId = group._id;
                    const newGroupId = newId + group._id.substring(id.length);
                    group._id = newGroupId;
                    // Create new object, then delete the old one if it worked
                    await this.setObject(newGroupId, group);
                    await this.delObject(oldGroupId);
                }
                // Then for the parent group
                const parentGroup = groups.find((g) => g._id === id);
                if (parentGroup) {
                    const oldGroupId = parentGroup._id;
                    parentGroup._id = newId;
                    if (newName !== undefined) {
                        parentGroup.common ??= {};
                        parentGroup.common.name = newName;
                    }
                    // Create new object, then delete the old one if it worked
                    await this.setObject(newId, parentGroup);
                    await this.delObject(oldGroupId);
                }
                resolve();
            },
        });
    }
    /**
     * Get the host information.
     * @param host
     * @param update Force update.
     * @param timeoutMs optional read timeout.
     */
    getHostInfo(host, update, timeoutMs) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: `hostInfo_${host}`,
            forceUpdate: update,
            commandTimeout: timeoutMs,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getHostInfo", null, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getHostInfo"');
                    }
                    else if (!data) {
                        reject('Cannot read "getHostInfo"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Get the host information (short version).
     * @param host
     * @param update Force update.
     * @param timeoutMs optional read timeout.
     */
    getHostInfoShort(host, update, timeoutMs) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: `hostInfoShort_${host}`,
            forceUpdate: update,
            commandTimeout: timeoutMs,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getHostInfoShort", null, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getHostInfoShort"');
                    }
                    else if (!data) {
                        reject('Cannot read "getHostInfoShort"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Get the repository.
     * @param host
     * @param args
     * @param update Force update.
     * @param timeoutMs timeout in ms.
     */
    getRepository(host, args, update, timeoutMs) {
        return this.request({
            cacheKey: "repo",
            forceUpdate: update,
            commandTimeout: timeoutMs,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getRepository", args, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getRepository"');
                    }
                    else if (!data) {
                        reject('Cannot read "getRepository"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Get the installed.
     * @param host
     * @param update Force update.
     * @param cmdTimeout timeout in ms
     */
    getInstalled(host, update, cmdTimeout) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: "installed",
            forceUpdate: update,
            commandTimeout: cmdTimeout,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getInstalled", null, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getInstalled"');
                    }
                    else if (!data) {
                        reject('Cannot read "getInstalled"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Execute a command on a host.
     * @param host The host name.
     * @param cmd The command.
     * @param cmdId The command ID.
     * @param cmdTimeout Timeout of command in ms
     */
    cmdExec(host, cmd, cmdId, cmdTimeout) {
        return this.request({
            commandTimeout: cmdTimeout,
            executor: (resolve, reject, timeout) => {
                host = normalizeHostId(host);
                this._socket.emit("cmdExec", host, cmdId, cmd, (err) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve();
                });
            },
        });
    }
    /**
     * Read the base settings of a given host.
     * @param host
     */
    readBaseSettings(host) {
        // Make sure we deal with a hostname, not an object ID
        host = objectIdToHostname(host);
        return this.request({
            requireFeatures: ["CONTROLLER_READWRITE_BASE_SETTINGS"],
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "readBaseSettings", null, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "BaseSettings"');
                    }
                    else if (!data) {
                        reject('Cannot read "BaseSettings"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Write the base settings of a given host.
     * @param host
     * @param config
     */
    writeBaseSettings(host, config) {
        // Make sure we deal with a hostname, not an object ID
        host = objectIdToHostname(host);
        return this.request({
            requireFeatures: ["CONTROLLER_READWRITE_BASE_SETTINGS"],
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "writeBaseSettings", config, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not write "BaseSettings"');
                    }
                    else if (!data) {
                        reject('Cannot write "BaseSettings"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Send command to restart the iobroker on host
     * @param host
     */
    restartController(host) {
        // Make sure we deal with a hostname, not an object ID
        host = objectIdToHostname(host);
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "restartController", null, (error) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (error)
                        reject(error);
                    resolve(true);
                });
            },
        });
    }
    /**
     * Read statistics information from host
     * @param host
     * @param typeOfDiag one of none, normal, no-city, extended
     */
    getDiagData(host, typeOfDiag) {
        // Make sure we deal with a hostname, not an object ID
        host = objectIdToHostname(host);
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getDiagData", typeOfDiag, (result) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    resolve(result);
                });
            },
        });
    }
    /**
     * Change the password of the given user.
     * @param user
     * @param password
     */
    changePassword(user, password) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("changePassword", user, password, (err) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve();
                });
            },
        });
    }
    /**
     * Get the IP addresses of the given host.
     * @param host
     * @param update Force update.
     */
    getIpAddresses(host, update) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: `IPs_${host}`,
            forceUpdate: update,
            // TODO: check if this should time out
            commandTimeout: false,
            executor: async (resolve) => {
                const obj = await this.getObject(host);
                resolve(obj?.common.address ?? []);
            },
        });
    }
    /**
     * Get the IP addresses with interface names of the given host or find host by IP.
     * @param ipOrHostName
     * @param update Force update.
     */
    getHostByIp(ipOrHostName, update) {
        // Make sure we deal with a hostname, not an object ID
        ipOrHostName = objectIdToHostname(ipOrHostName);
        return this.request({
            cacheKey: `rIPs_${ipOrHostName}`,
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getHostByIp", ipOrHostName, (ip, host) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    const { IPs4, IPs6 } = parseIPAddresses(host);
                    resolve([...IPs4, ...IPs6]);
                });
            },
        });
    }
    /**
     * Encrypt a text
     * @param plaintext
     */
    encrypt(plaintext) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("encrypt", plaintext, (err, ciphertext) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(ciphertext);
                });
            },
        });
    }
    /**
     * Decrypt a text
     * @param ciphertext
     */
    decrypt(ciphertext) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("decrypt", ciphertext, (err, plaintext) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(plaintext);
                });
            },
        });
    }
    /**
     * Change access rights for file
     * @param adapter adapter name
     * @param filename file name with full path. it could be like vis.0/*
     * @param options like {mode: 0x644}
     */
    chmodFile(adapter, path, options) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("chmodFile", adapter, path, options, (err, processed) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(processed);
                });
            },
        });
    }
    /**
     * Change owner or/and owner group for file
     * @param adapter adapter name
     * @param filename file name with full path. it could be like vis.0/*
     * @param options like {owner: 'newOwner', ownerGroup: 'newGroup'}
     */
    chownFile(adapter, filename, options) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("chownFile", adapter, filename, options, (err, processed) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(processed);
                });
            },
        });
    }
    /**
     * Get the alarm notifications from a host (only for admin connection).
     * @param host
     * @param category - optional
     */
    getNotifications(host, category) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "getNotifications", { category }, (notifications) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    resolve(notifications);
                });
            },
        });
    }
    /**
     * Clear the alarm notifications on a host (only for admin connection).
     * @param host
     * @param category - optional
     */
    clearNotifications(host, category) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("sendToHost", host, "clearNotifications", { category }, (notifications) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    resolve(notifications);
                });
            },
        });
    }
    /**
     * Read if only easy mode is allowed  (only for admin connection).
     */
    getIsEasyModeStrict() {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getIsEasyModeStrict", (err, isStrict) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(!!isStrict);
                });
            },
        });
    }
    /**
     * Read easy mode configuration (only for admin connection).
     */
    getEasyMode() {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getEasyMode", (err, config) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(config);
                });
            },
        });
    }
    /**
     * Read adapter ratings
     */
    getRatings(update) {
        return this.request({
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getRatings", !!update, (err, ratings) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(ratings);
                });
            },
        });
    }
    getCurrentSession(cmdTimeout) {
        const controller = new AbortController();
        return this.request({
            commandTimeout: cmdTimeout || 5000,
            onTimeout: () => {
                controller.abort();
            },
            executor: async (resolve, reject, timeout) => {
                try {
                    const res = await fetch("./session", {
                        signal: controller.signal,
                    });
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    resolve(res.json());
                }
                catch (e) {
                    reject(`getCurrentSession: ${e}`);
                }
            },
        });
    }
    /**
     * Read current web, socketio or admin namespace, like admin.0
     */
    getCurrentInstance() {
        return this.request({
            cacheKey: "currentInstance",
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCurrentInstance", (err, namespace) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(namespace);
                });
            },
        });
    }
    /**
     * Get all adapter instances.
     * @param update Force update.
     */
    /**
     * Get all instances of the given adapter.
     * @param adapter The name of the adapter.
     * @param update Force update.
     */
    getAdapterInstances(adapter, update) {
        if (typeof adapter === "boolean") {
            update = adapter;
            adapter = "";
        }
        adapter = adapter ?? "";
        return this.request({
            cacheKey: `instances_${adapter}`,
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getAdapterInstances", adapter, (err, instances) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(instances);
                });
            },
        });
    }
    /**
     * Get all adapters.
     * @param update Force update.
     */
    /**
     * Get adapters with the given name.
     * @param adapter The name of the adapter.
     * @param update Force update.
     */
    getAdapters(adapter, update) {
        if (typeof adapter === "boolean") {
            update = adapter;
            adapter = "";
        }
        adapter = adapter ?? "";
        return this.request({
            cacheKey: `adapter_${adapter}`,
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getAdapters", adapter, (err, adapters) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(adapters);
                });
            },
        });
    }
    // returns very optimized information for adapters to minimize connection load
    getCompactAdapters(update) {
        return this.request({
            cacheKey: "compactAdapters",
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCompactAdapters", (err, adapters) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(adapters);
                });
            },
        });
    }
    // returns very optimized information for adapters to minimize connection load
    getCompactInstances(update) {
        return this.request({
            cacheKey: "compactInstances",
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCompactInstances", (err, instances) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(instances);
                });
            },
        });
    }
    // returns very optimized information for adapters to minimize connection load
    // reads only version of installed adapter
    getCompactInstalled(host, update, cmdTimeout) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: `installedCompact_${host}`,
            forceUpdate: update,
            commandTimeout: cmdTimeout,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCompactInstalled", host, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getCompactInstalled"');
                    }
                    else if (!data) {
                        reject('Cannot read "getCompactInstalled"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Get the repository in compact form (only version and icon).
     * @param host
     * @param update Force update.
     * @param timeoutMs timeout in ms.
     */
    getCompactRepository(host, update, timeoutMs) {
        host = normalizeHostId(host);
        return this.request({
            cacheKey: `repositoryCompact_${host}`,
            forceUpdate: update,
            commandTimeout: timeoutMs,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCompactRepository", host, (data) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (data === ERRORS.PERMISSION_ERROR) {
                        reject('May not read "getCompactRepository"');
                    }
                    else if (!data) {
                        reject('Cannot read "getCompactRepository"');
                    }
                    else {
                        resolve(data);
                    }
                });
            },
        });
    }
    /**
     * Get the list of all hosts in compact form (only _id, common.name, common.icon, common.color, native.hardware.networkInterfaces)
     * @param update Force update.
     */
    getCompactHosts(update) {
        return this.request({
            cacheKey: "hostsCompact",
            forceUpdate: update,
            executor: (resolve, reject, timeout) => {
                this._socket.emit("getCompactHosts", (err, systemConfig) => {
                    if (timeout.elapsed)
                        return;
                    timeout.clearTimeout();
                    if (err)
                        reject(err);
                    resolve(systemConfig);
                });
            },
        });
    }
}
//# sourceMappingURL=AdminConnection.js.map