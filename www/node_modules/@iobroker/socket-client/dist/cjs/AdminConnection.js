var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  AdminConnection: () => AdminConnection
});
var import_Connection = __toModule(require("./Connection.js"));
var import_tools = __toModule(require("./tools.js"));
function parseCertificate(name, cert) {
  if (!cert)
    return;
  let type;
  if (cert.length < 700 && (cert.indexOf("/") !== -1 || cert.indexOf("\\") !== -1)) {
    if (name.toLowerCase().includes("private")) {
      type = "private";
    } else if (cert.toLowerCase().includes("private")) {
      type = "private";
    } else if (name.toLowerCase().includes("public")) {
      type = "public";
    } else if (cert.toLowerCase().includes("public")) {
      type = "public";
    } else {
      return;
    }
  } else {
    type = cert.substring(0, "-----BEGIN RSA PRIVATE KEY".length) === "-----BEGIN RSA PRIVATE KEY" || cert.substring(0, "-----BEGIN PRIVATE KEY".length) === "-----BEGIN PRIVATE KEY" ? "private" : "public";
    if (type === "public") {
      const m = cert.split("-----END CERTIFICATE-----");
      if (m.filter((t) => t.replace(/\r\n|\r|\n/, "").trim()).length > 1) {
        type = "chained";
      }
    }
  }
  return { name, type };
}
function parseIPAddresses(host) {
  var _a, _b;
  const IPs4 = [
    {
      name: "[IPv4] 0.0.0.0 - Listen on all IPs",
      address: "0.0.0.0",
      family: "ipv4"
    }
  ];
  const IPs6 = [
    {
      name: "[IPv6] :: - Listen on all IPs",
      address: "::",
      family: "ipv6"
    }
  ];
  if ((_b = (_a = host.native) === null || _a === void 0 ? void 0 : _a.hardware) === null || _b === void 0 ? void 0 : _b.networkInterfaces) {
    for (const [eth, iface] of Object.entries(host.native.hardware.networkInterfaces)) {
      if (!iface)
        continue;
      for (const ip of iface) {
        if (ip.family !== "IPv6") {
          IPs4.push({
            name: `[${ip.family}] ${ip.address} - ${eth}`,
            address: ip.address,
            family: "ipv4"
          });
        } else {
          IPs6.push({
            name: `[${ip.family}] ${ip.address} - ${eth}`,
            address: ip.address,
            family: "ipv6"
          });
        }
      }
    }
  }
  return { IPs4, IPs6 };
}
class AdminConnection extends import_Connection.Connection {
  constructor(props) {
    super(props);
  }
  request(options) {
    return super.request(__spreadValues({ requireAdmin: true }, options));
  }
  getCertificates(update) {
    return this.request({
      cacheKey: "cert",
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject("system.certificates");
        if ((_a = obj === null || obj === void 0 ? void 0 : obj.native) === null || _a === void 0 ? void 0 : _a.certificates) {
          resolve(Object.entries(obj.native.certificates).map(([name, cert]) => parseCertificate(name, cert)).filter((cert) => !!cert));
        } else {
          resolve([]);
        }
      }
    });
  }
  getLogs(host, linesNumber = 200) {
    return this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("sendToHost", host, "getLogs", linesNumber || 200, (lines) => {
          resolve(lines);
        });
      }
    });
  }
  getLogsFiles(host) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("readLogs", host, (err, files) => {
          if (err)
            reject(err);
          resolve(files);
        });
      }
    });
  }
  delLogs(host) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("sendToHost", host, "delLogs", null, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  deleteFile(adapter, fileName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFile", adapter, fileName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  deleteFolder(adapter, folderName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFolder", adapter, folderName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getHosts(update) {
    return this.request({
      cacheKey: "hosts",
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "host", { startkey: "system.host.", endkey: "system.host.\u9999" }, (err, doc) => {
          if (err) {
            reject(err);
          } else {
            resolve((0, import_tools.getObjectViewResultToArray)(doc));
          }
        });
      }
    });
  }
  getUsers(update) {
    return this.request({
      cacheKey: "users",
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "user", { startkey: "system.user.", endkey: "system.user.\u9999" }, (err, doc) => {
          if (err) {
            reject(err);
          } else {
            resolve((0, import_tools.getObjectViewResultToArray)(doc));
          }
        });
      }
    });
  }
  getGroups(update) {
    return this.request({
      cacheKey: "groups",
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "group", {
          startkey: "system.group.",
          endkey: "system.group.\u9999"
        }, (err, doc) => {
          if (err) {
            reject(err);
          } else {
            resolve((0, import_tools.getObjectViewResultToArray)(doc));
          }
        });
      }
    });
  }
  renameGroup(id, newId, newName) {
    return this.request({
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const groups = await this.getGroups(true);
        const subGroups = groups.filter((g) => g._id.startsWith(`${id}.`));
        for (const group of subGroups) {
          const oldGroupId = group._id;
          const newGroupId = newId + group._id.substring(id.length);
          group._id = newGroupId;
          await this.setObject(newGroupId, group);
          await this.delObject(oldGroupId);
        }
        const parentGroup = groups.find((g) => g._id === id);
        if (parentGroup) {
          const oldGroupId = parentGroup._id;
          parentGroup._id = newId;
          if (newName !== void 0) {
            (_a = parentGroup.common) !== null && _a !== void 0 ? _a : parentGroup.common = {};
            parentGroup.common.name = newName;
          }
          await this.setObject(newId, parentGroup);
          await this.delObject(oldGroupId);
        }
        resolve();
      }
    });
  }
  getHostInfo(host, update, timeoutMs) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `hostInfo_${host}`,
      forceUpdate: update,
      commandTimeout: timeoutMs,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getHostInfo", null, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getHostInfo"');
          } else if (!data) {
            reject('Cannot read "getHostInfo"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  getHostInfoShort(host, update, timeoutMs) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `hostInfoShort_${host}`,
      forceUpdate: update,
      commandTimeout: timeoutMs,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getHostInfoShort", null, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getHostInfoShort"');
          } else if (!data) {
            reject('Cannot read "getHostInfoShort"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  getRepository(host, args, update, timeoutMs) {
    return this.request({
      cacheKey: "repo",
      forceUpdate: update,
      commandTimeout: timeoutMs,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getRepository", args, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getRepository"');
          } else if (!data) {
            reject('Cannot read "getRepository"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  getInstalled(host, update, cmdTimeout) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: "installed",
      forceUpdate: update,
      commandTimeout: cmdTimeout,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getInstalled", null, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getInstalled"');
          } else if (!data) {
            reject('Cannot read "getInstalled"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  cmdExec(host, cmd, cmdId, cmdTimeout) {
    return this.request({
      commandTimeout: cmdTimeout,
      executor: (resolve, reject, timeout) => {
        host = (0, import_tools.normalizeHostId)(host);
        this._socket.emit("cmdExec", host, cmdId, cmd, (err) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  readBaseSettings(host) {
    host = (0, import_tools.objectIdToHostname)(host);
    return this.request({
      requireFeatures: ["CONTROLLER_READWRITE_BASE_SETTINGS"],
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "readBaseSettings", null, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "BaseSettings"');
          } else if (!data) {
            reject('Cannot read "BaseSettings"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  writeBaseSettings(host, config) {
    host = (0, import_tools.objectIdToHostname)(host);
    return this.request({
      requireFeatures: ["CONTROLLER_READWRITE_BASE_SETTINGS"],
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "writeBaseSettings", config, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not write "BaseSettings"');
          } else if (!data) {
            reject('Cannot write "BaseSettings"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  restartController(host) {
    host = (0, import_tools.objectIdToHostname)(host);
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "restartController", null, (error) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (error)
            reject(error);
          resolve(true);
        });
      }
    });
  }
  getDiagData(host, typeOfDiag) {
    host = (0, import_tools.objectIdToHostname)(host);
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getDiagData", typeOfDiag, (result) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          resolve(result);
        });
      }
    });
  }
  changePassword(user, password) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("changePassword", user, password, (err) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getIpAddresses(host, update) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `IPs_${host}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject(host);
        resolve((_a = obj === null || obj === void 0 ? void 0 : obj.common.address) !== null && _a !== void 0 ? _a : []);
      }
    });
  }
  getHostByIp(ipOrHostName, update) {
    ipOrHostName = (0, import_tools.objectIdToHostname)(ipOrHostName);
    return this.request({
      cacheKey: `rIPs_${ipOrHostName}`,
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getHostByIp", ipOrHostName, (ip, host) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          const { IPs4, IPs6 } = parseIPAddresses(host);
          resolve([...IPs4, ...IPs6]);
        });
      }
    });
  }
  encrypt(plaintext) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("encrypt", plaintext, (err, ciphertext) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(ciphertext);
        });
      }
    });
  }
  decrypt(ciphertext) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("decrypt", ciphertext, (err, plaintext) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(plaintext);
        });
      }
    });
  }
  chmodFile(adapter, path, options) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("chmodFile", adapter, path, options, (err, processed) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(processed);
        });
      }
    });
  }
  chownFile(adapter, filename, options) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("chownFile", adapter, filename, options, (err, processed) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(processed);
        });
      }
    });
  }
  getNotifications(host, category) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "getNotifications", { category }, (notifications) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          resolve(notifications);
        });
      }
    });
  }
  clearNotifications(host, category) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("sendToHost", host, "clearNotifications", { category }, (notifications) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          resolve(notifications);
        });
      }
    });
  }
  getIsEasyModeStrict() {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getIsEasyModeStrict", (err, isStrict) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(!!isStrict);
        });
      }
    });
  }
  getEasyMode() {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getEasyMode", (err, config) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(config);
        });
      }
    });
  }
  getRatings(update) {
    return this.request({
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getRatings", !!update, (err, ratings) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(ratings);
        });
      }
    });
  }
  getCurrentSession(cmdTimeout) {
    const controller = new AbortController();
    return this.request({
      commandTimeout: cmdTimeout || 5e3,
      onTimeout: () => {
        controller.abort();
      },
      executor: async (resolve, reject, timeout) => {
        try {
          const res = await fetch("./session", {
            signal: controller.signal
          });
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          resolve(res.json());
        } catch (e) {
          reject(`getCurrentSession: ${e}`);
        }
      }
    });
  }
  getCurrentInstance() {
    return this.request({
      cacheKey: "currentInstance",
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCurrentInstance", (err, namespace) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(namespace);
        });
      }
    });
  }
  getAdapterInstances(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter !== null && adapter !== void 0 ? adapter : "";
    return this.request({
      cacheKey: `instances_${adapter}`,
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getAdapterInstances", adapter, (err, instances) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(instances);
        });
      }
    });
  }
  getAdapters(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter !== null && adapter !== void 0 ? adapter : "";
    return this.request({
      cacheKey: `adapter_${adapter}`,
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getAdapters", adapter, (err, adapters) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(adapters);
        });
      }
    });
  }
  getCompactAdapters(update) {
    return this.request({
      cacheKey: "compactAdapters",
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCompactAdapters", (err, adapters) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(adapters);
        });
      }
    });
  }
  getCompactInstances(update) {
    return this.request({
      cacheKey: "compactInstances",
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCompactInstances", (err, instances) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(instances);
        });
      }
    });
  }
  getCompactInstalled(host, update, cmdTimeout) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `installedCompact_${host}`,
      forceUpdate: update,
      commandTimeout: cmdTimeout,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCompactInstalled", host, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getCompactInstalled"');
          } else if (!data) {
            reject('Cannot read "getCompactInstalled"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  getCompactRepository(host, update, timeoutMs) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `repositoryCompact_${host}`,
      forceUpdate: update,
      commandTimeout: timeoutMs,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCompactRepository", host, (data) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (data === import_Connection.ERRORS.PERMISSION_ERROR) {
            reject('May not read "getCompactRepository"');
          } else if (!data) {
            reject('Cannot read "getCompactRepository"');
          } else {
            resolve(data);
          }
        });
      }
    });
  }
  getCompactHosts(update) {
    return this.request({
      cacheKey: "hostsCompact",
      forceUpdate: update,
      executor: (resolve, reject, timeout) => {
        this._socket.emit("getCompactHosts", (err, systemConfig) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve(systemConfig);
        });
      }
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AdminConnection
});
//# sourceMappingURL=AdminConnection.js.map
