"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Connection_exports = {};
__export(Connection_exports, {
  Connection: () => Connection,
  ERRORS: () => ERRORS,
  NOT_CONNECTED: () => NOT_CONNECTED,
  PERMISSION_ERROR: () => PERMISSION_ERROR,
  PROGRESS: () => PROGRESS
});
module.exports = __toCommonJS(Connection_exports);
var import_DeferredPromise = require("./DeferredPromise.js");
var import_tools = require("./tools.js");
var PROGRESS;
(function(PROGRESS2) {
  PROGRESS2[PROGRESS2["CONNECTING"] = 0] = "CONNECTING";
  PROGRESS2[PROGRESS2["CONNECTED"] = 1] = "CONNECTED";
  PROGRESS2[PROGRESS2["OBJECTS_LOADED"] = 2] = "OBJECTS_LOADED";
  PROGRESS2[PROGRESS2["READY"] = 3] = "READY";
})(PROGRESS || (PROGRESS = {}));
var ERRORS;
(function(ERRORS2) {
  ERRORS2["PERMISSION_ERROR"] = "permissionError";
  ERRORS2["NOT_CONNECTED"] = "notConnectedError";
  ERRORS2["TIMEOUT"] = "timeout";
  ERRORS2["NOT_ADMIN"] = "Allowed only in admin";
  ERRORS2["NOT_SUPPORTED"] = "Not supported";
})(ERRORS || (ERRORS = {}));
const PERMISSION_ERROR = ERRORS.PERMISSION_ERROR;
const NOT_CONNECTED = ERRORS.NOT_CONNECTED;
const ADAPTERS = ["material", "echarts", "vis"];
class Connection {
  constructor(props) {
    this.ignoreState = "";
    this.connected = false;
    this.subscribed = false;
    this.firstConnect = true;
    this.waitForRestart = false;
    this.loaded = false;
    this.simStates = {};
    this.statesSubscribes = {};
    this.filesSubscribes = {};
    this.objectsSubscribes = {};
    this.objects = {};
    this.states = {};
    this.acl = null;
    this.isSecure = false;
    this.onConnectionHandlers = [];
    this.onLogHandlers = [];
    this._waitForFirstConnectionPromise = (0, import_DeferredPromise.createDeferredPromise)();
    this._instanceSubscriptions = {};
    this._promises = {};
    this._systemLang = "en";
    this.props = this.applyDefaultProps(props);
    this.waitForSocketLib().then(() => this.startSocket()).catch((e) => {
      alert(`Socket connection could not be initialized: ${e}`);
    });
  }
  applyDefaultProps(props) {
    var _a, _b, _c, _d;
    return {
      ...props,
      protocol: props.protocol || window.location.protocol,
      host: props.host || window.location.hostname,
      port: props.port || (window.location.port === "3000" ? 8081 : window.location.port),
      ioTimeout: Math.max(props.ioTimeout || 2e4, 2e4),
      cmdTimeout: Math.max(props.cmdTimeout || 5e3, 5e3),
      admin5only: props.admin5only || false,
      autoSubscribes: (_a = props.autoSubscribes) !== null && _a !== void 0 ? _a : [],
      autoSubscribeLog: (_b = props.autoSubscribeLog) !== null && _b !== void 0 ? _b : false,
      doNotLoadACL: (_c = props.doNotLoadACL) !== null && _c !== void 0 ? _c : true,
      doNotLoadAllObjects: (_d = props.doNotLoadAllObjects) !== null && _d !== void 0 ? _d : true
    };
  }
  onError(error) {
    var _a;
    ((_a = this.props.onError) !== null && _a !== void 0 ? _a : console.error)(error);
  }
  get systemConfig() {
    return this._systemConfig;
  }
  get systemLang() {
    return this._systemLang;
  }
  static isWeb() {
    return window.socketUrl !== void 0;
  }
  waitForSocketLib() {
    if (this._waitForSocketPromise)
      return this._waitForSocketPromise;
    this._waitForSocketPromise = new Promise(async (resolve, reject) => {
      if (typeof window.io === "undefined") {
        if (typeof window.registerSocketOnLoad === "function") {
          window.registerSocketOnLoad(() => resolve());
        } else {
          for (let i = 1; i <= 30; i++) {
            if (window.io)
              return resolve();
            await (0, import_tools.wait)(100);
          }
          reject(new Error("Socket library could not be loaded!"));
        }
      } else {
        resolve();
      }
    });
    return this._waitForSocketPromise;
  }
  async startSocket() {
    if (this._socket)
      return;
    let host = this.props.host;
    let port = this.props.port;
    let protocol = this.props.protocol.replace(":", "");
    let path = window.location.pathname;
    if (window.location.hostname === "iobroker.net" || window.location.hostname === "iobroker.pro") {
      path = "";
    } else {
      if (window.socketUrl) {
        const parsed = new URL(window.socketUrl);
        host = parsed.hostname;
        port = parsed.port;
        protocol = parsed.protocol.replace(":", "");
      }
      const pos = path.lastIndexOf("/");
      if (pos !== -1) {
        path = path.substring(0, pos + 1);
      }
      if (Connection.isWeb()) {
        const parts = path.split("/");
        if (parts.length > 2) {
          parts.pop();
          parts.pop();
          if (ADAPTERS.includes(parts[parts.length - 1])) {
            parts.pop();
          }
          path = parts.join("/");
          if (!path.endsWith("/")) {
            path += "/";
          }
        }
      }
    }
    const url = port ? `${protocol}://${host}:${port}` : `${protocol}://${host}`;
    this._socket = window.io.connect(url, {
      path: path.endsWith("/") ? `${path}socket.io` : `${path}/socket.io`,
      query: "ws=true",
      name: this.props.name,
      timeout: this.props.ioTimeout,
      uuid: this.props.uuid,
      token: this.props.token
    });
    this._socket.on("connect", (noTimeout) => {
      if (noTimeout !== true) {
        this.connected = true;
        setTimeout(() => this.getVersion().then((info) => {
          const [major, minor, patch] = info.version.split(".");
          const v = parseInt(major, 10) * 1e4 + parseInt(minor, 10) * 100 + parseInt(patch, 10);
          if (v < 40102) {
            this._authTimer = null;
            this.onPreConnect(false, false);
          } else {
            this._socket.emit("authenticate", (isOk, isSecure) => this.onPreConnect(isOk, isSecure));
          }
        }).catch((e) => this.onError({
          message: e.toString(),
          operation: "getVersion"
        })), 500);
      } else {
        this._socket.emit("authenticate", (isOk, isSecure) => {
          this.onPreConnect(isOk, isSecure);
        });
      }
    });
    this._socket.on("reconnect", () => {
      var _a, _b;
      (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.READY);
      this.connected = true;
      if (this.waitForRestart) {
        window.location.reload();
      } else {
        this._subscribe(true);
        this.onConnectionHandlers.forEach((cb) => cb(true));
      }
    });
    this._socket.on("disconnect", () => {
      var _a, _b;
      this.connected = false;
      this.subscribed = false;
      (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.CONNECTING);
      this.onConnectionHandlers.forEach((cb) => cb(false));
    });
    this._socket.on("reauthenticate", () => this.authenticate());
    this._socket.on("log", (message) => {
      var _a, _b;
      (_b = (_a = this.props).onLog) === null || _b === void 0 ? void 0 : _b.call(_a, message);
      this.onLogHandlers.forEach((cb) => cb(message));
    });
    this._socket.on("error", (err) => {
      let _err;
      if (err == void 0) {
        _err = "";
      } else if (typeof err.toString === "function") {
        _err = err.toString();
      } else {
        _err = JSON.stringify(err);
        console.error(`Received strange error: ${_err}`);
      }
      if (_err.includes("User not authorized")) {
        this.authenticate();
      } else if (_err.includes("websocket error")) {
        console.error(`Socket Error => reload: ${err}`);
        window.location.reload();
      } else {
        console.error(`Socket Error: ${err}`);
      }
    });
    this._socket.on("connect_error", (err) => console.error(`Connect error: ${err}`));
    this._socket.on("permissionError", (err) => this.onError({
      message: "no permission",
      operation: err.operation,
      type: err.type,
      id: err.id || ""
    }));
    this._socket.on("objectChange", (id, obj) => {
      setTimeout(() => this.objectChange(id, obj), 0);
    });
    this._socket.on("stateChange", (id, state) => {
      setTimeout(() => this.stateChange(id, state), 0);
    });
    this._socket.on("im", (messageType, from, data) => {
      setTimeout(() => this.instanceMessage(messageType, from, data), 0);
    });
    this._socket.on("fileChange", (id, fileName, size) => {
      setTimeout(() => this.fileChange(id, fileName, size), 0);
    });
    this._socket.on("cmdStdout", (id, text) => {
      var _a;
      (_a = this.onCmdStdoutHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, text);
    });
    this._socket.on("cmdStderr", (id, text) => {
      var _a;
      (_a = this.onCmdStderrHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, text);
    });
    this._socket.on("cmdExit", (id, exitCode) => {
      var _a;
      (_a = this.onCmdExitHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, exitCode);
    });
  }
  onPreConnect(isOk, isSecure) {
    var _a, _b;
    if (this._authTimer) {
      clearTimeout(this._authTimer);
      this._authTimer = null;
    }
    this.connected = true;
    this.isSecure = isSecure;
    if (this.waitForRestart) {
      window.location.reload();
    } else {
      if (this.firstConnect) {
        this.loadData();
      } else {
        (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.READY);
      }
      this._subscribe(true);
      this.onConnectionHandlers.forEach((cb) => cb(true));
    }
    this._waitForFirstConnectionPromise.resolve();
  }
  isConnected() {
    return this.connected;
  }
  waitForFirstConnection() {
    return this._waitForFirstConnectionPromise;
  }
  async getUserPermissions() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getUserPermissions", (err, acl) => {
          if (err)
            reject(err);
          resolve(acl);
        });
      }
    });
  }
  async loadData() {
    if (this.loaded)
      return;
    const maxAttempts = 10;
    for (let i = 1; i <= maxAttempts; i++) {
      this.doLoadData();
      if (this.loaded)
        return;
      await (0, import_tools.wait)(1e3);
    }
  }
  async doLoadData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (this.loaded)
      return;
    if (!this.props.doNotLoadACL) {
      try {
        this.acl = await this.getUserPermissions();
      } catch (e) {
        this.onError(`Cannot read user permissions: ${e}`);
        return;
      }
    }
    try {
      if (this.props.admin5only && !Connection.isWeb() && (!window.vendorPrefix || window.vendorPrefix === "@@vendorPrefix@@")) {
        this._systemConfig = await this.getCompactSystemConfig();
      } else {
        this._systemConfig = await this.getSystemConfig();
      }
    } catch (e) {
      this.onError(`Cannot read system config: ${e}`);
      return;
    }
    this._systemLang = (_a = this._systemConfig.common) === null || _a === void 0 ? void 0 : _a.language;
    if (!this._systemLang) {
      this._systemLang = window.navigator.userLanguage || window.navigator.language;
      if (/^(en|de|ru|pt|nl|fr|it|es|pl|uk)-?/.test(this._systemLang)) {
        this._systemLang = this._systemLang.substr(0, 2);
      } else if (!/^(en|de|ru|pt|nl|fr|it|es|pl|uk|zh-cn)$/.test(this._systemLang)) {
        this._systemLang = "en";
      }
      this._systemConfig.common.language = this._systemLang;
    }
    (_c = (_b = this.props).onLanguage) === null || _c === void 0 ? void 0 : _c.call(_b, this.systemLang);
    this.loaded = true;
    (_e = (_d = this.props).onProgress) === null || _e === void 0 ? void 0 : _e.call(_d, PROGRESS.CONNECTED);
    this.firstConnect = false;
    if (!this.props.doNotLoadAllObjects) {
      this.objects = await this.getObjects();
    } else if (this.props.admin5only) {
      this.objects = {};
    } else {
      this.objects = { "system.config": this._systemConfig };
    }
    (_g = (_f = this.props).onProgress) === null || _g === void 0 ? void 0 : _g.call(_f, PROGRESS.READY);
    (_j = (_h = this.props).onReady) === null || _j === void 0 ? void 0 : _j.call(_h, this.objects);
  }
  authenticate() {
    if (window.location.search.includes("&href=")) {
      window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;
    } else {
      window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}?login&href=${window.location.search}${window.location.hash}`;
    }
  }
  async subscribeState(...args) {
    let id;
    let binary;
    let cb;
    if (args.length === 3) {
      [id, binary, cb] = args;
    } else {
      [id, cb] = args;
      binary = false;
    }
    if (typeof cb !== "function") {
      throw new Error("The state change handler must be a function!");
    }
    if (!this.statesSubscribes[id]) {
      this.statesSubscribes[id] = {
        reg: new RegExp((0, import_tools.pattern2RegEx)(id)),
        cbs: [cb]
      };
      if (this.connected && id !== this.ignoreState) {
        this._socket.emit("subscribe", id);
      }
    } else {
      !this.statesSubscribes[id].cbs.includes(cb) && this.statesSubscribes[id].cbs.push(cb);
    }
    if (this.connected) {
      if (binary) {
        let base64;
        try {
          base64 = await this.getBinaryState(id);
        } catch (e) {
          console.error(`Cannot getBinaryState "${id}": ${JSON.stringify(e)}`);
        }
        if (base64 != void 0) {
          cb(id, base64);
        }
      } else {
        let states;
        try {
          states = await this.getForeignStates(id);
        } catch (e) {
          console.error(`Cannot getForeignStates "${id}": ${JSON.stringify(e)}`);
          return;
        }
        if (states) {
          for (const [id2, state] of Object.entries(states)) {
            cb(id2, state);
          }
        }
      }
    }
  }
  async subscribeStateAsync(id, cb) {
    return this.subscribeState(id, cb);
  }
  unsubscribeState(id, cb) {
    if (this.statesSubscribes[id]) {
      const sub = this.statesSubscribes[id];
      if (cb) {
        const pos = sub.cbs.indexOf(cb);
        pos !== -1 && sub.cbs.splice(pos, 1);
      } else {
        sub.cbs = [];
      }
      if (!sub.cbs || !sub.cbs.length) {
        delete this.statesSubscribes[id];
        if (this.connected && id !== this.ignoreState) {
          this._socket.emit("unsubscribe", id);
        }
      }
    }
  }
  subscribeObject(id, cb) {
    if (!this.objectsSubscribes[id]) {
      this.objectsSubscribes[id] = {
        reg: new RegExp((0, import_tools.pattern2RegEx)(id)),
        cbs: [cb]
      };
      this.connected && this._socket.emit("subscribeObjects", id);
    } else {
      !this.objectsSubscribes[id].cbs.includes(cb) && this.objectsSubscribes[id].cbs.push(cb);
    }
    return Promise.resolve();
  }
  unsubscribeObject(id, cb) {
    if (this.objectsSubscribes[id]) {
      const sub = this.objectsSubscribes[id];
      if (cb) {
        const pos = sub.cbs.indexOf(cb);
        pos !== -1 && sub.cbs.splice(pos, 1);
      } else {
        sub.cbs = [];
      }
      if (this.connected && (!sub.cbs || !sub.cbs.length)) {
        delete this.objectsSubscribes[id];
        this.connected && this._socket.emit("unsubscribeObjects", id);
      }
    }
    return Promise.resolve();
  }
  objectChange(id, obj) {
    var _a, _b;
    let oldObj;
    if (this.objects[id]) {
      oldObj = { _id: id, type: this.objects[id].type };
    }
    let changed = false;
    if (obj) {
      if (obj._rev && this.objects[id]) {
        this.objects[id]._rev = obj._rev;
      }
      if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {
        this.objects[id] = obj;
        changed = true;
      }
    } else if (this.objects[id]) {
      delete this.objects[id];
      changed = true;
    }
    for (const [_id, sub] of Object.entries(this.objectsSubscribes)) {
      if (_id === id || sub.reg.test(id)) {
        sub.cbs.forEach((cb) => {
          try {
            cb(id, obj, oldObj);
          } catch (e) {
            console.error(`Error by callback of objectChange: ${e}`);
          }
        });
      }
    }
    if (changed)
      (_b = (_a = this.props).onObjectChange) === null || _b === void 0 ? void 0 : _b.call(_a, id, obj);
  }
  stateChange(id, state) {
    for (const sub of Object.values(this.statesSubscribes)) {
      if (sub.reg.test(id)) {
        for (const cb of sub.cbs) {
          try {
            cb(id, state !== null && state !== void 0 ? state : null);
          } catch (e) {
            console.error(`Error by callback of stateChanged: ${e}`);
          }
        }
      }
    }
  }
  instanceMessage(messageType, sourceInstance, data) {
    var _a;
    (_a = this._instanceSubscriptions[sourceInstance]) === null || _a === void 0 ? void 0 : _a.forEach((sub) => {
      if (sub.messageType === messageType) {
        sub.callback(data, sourceInstance, messageType);
      }
    });
  }
  fileChange(id, fileName, size) {
    for (const sub of Object.values(this.filesSubscribes)) {
      if (sub.regId.test(id) && sub.regFilePattern.test(fileName)) {
        for (const cb of sub.cbs) {
          try {
            cb(id, fileName, size);
          } catch (e) {
            console.error(`Error by callback of fileChange: ${e}`);
          }
        }
      }
    }
  }
  async subscribeFiles(id, filePattern, cb) {
    if (typeof cb !== "function") {
      throw new Error("The state change handler must be a function!");
    }
    const key = `${id}$%$${filePattern}`;
    if (!this.filesSubscribes[key]) {
      this.filesSubscribes[key] = {
        regId: new RegExp((0, import_tools.pattern2RegEx)(id)),
        regFilePattern: new RegExp((0, import_tools.pattern2RegEx)(filePattern)),
        cbs: [cb]
      };
      this.connected && this._socket.emit("subscribeFiles", id, filePattern);
    } else {
      !this.filesSubscribes[key].cbs.includes(cb) && this.filesSubscribes[key].cbs.push(cb);
    }
  }
  unsubscribeFiles(id, filePattern, cb) {
    const key = `${id}$%$${filePattern}`;
    if (this.filesSubscribes[key]) {
      const sub = this.filesSubscribes[key];
      if (cb) {
        const pos = sub.cbs.indexOf(cb);
        pos !== -1 && sub.cbs.splice(pos, 1);
      } else {
        sub.cbs = [];
      }
      if (!sub.cbs || !sub.cbs.length) {
        delete this.filesSubscribes[key];
        this.connected && this._socket.emit("unsubscribeFiles", id, filePattern);
      }
    }
  }
  async request({
    cacheKey,
    forceUpdate,
    commandTimeout,
    onTimeout,
    requireAdmin,
    requireFeatures,
    executor
  }) {
    if (requireAdmin && Connection.isWeb()) {
      return Promise.reject(ERRORS.NOT_ADMIN);
    }
    if (cacheKey && !forceUpdate && cacheKey in this._promises) {
      return this._promises[cacheKey];
    }
    if (!this.connected) {
      return Promise.reject(ERRORS.NOT_CONNECTED);
    }
    if (requireFeatures === null || requireFeatures === void 0 ? void 0 : requireFeatures.length) {
      for (const feature of requireFeatures) {
        if (!await this.checkFeatureSupported(feature)) {
          throw ERRORS.NOT_SUPPORTED;
        }
      }
    }
    const promise = new Promise(async (resolve, reject) => {
      const timeoutControl = {
        elapsed: false,
        clearTimeout: () => {
        }
      };
      let timeout;
      if (commandTimeout !== false) {
        timeout = setTimeout(() => {
          timeoutControl.elapsed = true;
          onTimeout === null || onTimeout === void 0 ? void 0 : onTimeout();
          reject(ERRORS.TIMEOUT);
        }, commandTimeout !== null && commandTimeout !== void 0 ? commandTimeout : this.props.cmdTimeout);
        timeoutControl.clearTimeout = () => {
          clearTimeout(timeout);
        };
      }
      try {
        await executor(resolve, reject, timeoutControl);
      } catch (e) {
        reject(e);
      }
    });
    if (cacheKey) {
      this._promises[cacheKey] = promise;
    }
    return promise;
  }
  resetCache(key, isAll) {
    if (isAll) {
      Object.keys(this._promises).filter((k) => k.startsWith(key)).forEach((k) => {
        delete this._promises[k];
      });
    } else {
      delete this._promises[key];
    }
  }
  getStates(pattern) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getStates", pattern, (err, res) => {
          this.states = res !== null && res !== void 0 ? res : {};
          if (err)
            reject(err);
          resolve(this.states);
        });
      }
    });
  }
  getState(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (id && id === this.ignoreState) {
          resolve(this.simStates[id] || { val: null, ack: true });
          return;
        }
        this._socket.emit("getState", id, (err, state) => {
          if (err)
            reject(err);
          resolve(state);
        });
      }
    });
  }
  getBinaryState(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getBinaryState", id, (err, state) => {
          if (err)
            reject(err);
          resolve(state);
        });
      }
    });
  }
  setBinaryState(id, base64) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("setBinaryState", id, base64, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  setState(id, val, ack) {
    if (typeof ack === "boolean") {
      val = { val, ack };
    }
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (id && id === this.ignoreState) {
          let state;
          if (typeof ack === "boolean") {
            state = val;
          } else if (typeof val === "object" && val.val !== void 0) {
            state = val;
          } else {
            state = {
              val,
              ack: false,
              ts: Date.now(),
              lc: Date.now(),
              from: "system.adapter.vis.0"
            };
          }
          this.simStates[id] = state;
          if (this.statesSubscribes[id]) {
            for (const cb of this.statesSubscribes[id].cbs) {
              try {
                cb(id, state);
              } catch (e) {
                console.error(`Error by callback of stateChanged: ${e}`);
              }
            }
          }
          resolve();
          return;
        }
        this._socket.emit("setState", id, val, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getObjects(update, disableProgressUpdate) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (!update && this.objects) {
          resolve(this.objects);
          return;
        }
        this._socket.emit(Connection.isWeb() ? "getObjects" : "getAllObjects", (err, res) => {
          var _a, _b;
          if (!disableProgressUpdate)
            (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.OBJECTS_LOADED);
          if (err)
            reject(err);
          this.objects = res !== null && res !== void 0 ? res : {};
          resolve(this.objects);
        });
      }
    });
  }
  getObjectsById(list) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjects", list, (err, res) => {
          if (err)
            reject(err);
          resolve(res);
        });
      }
    });
  }
  _subscribe(isEnable) {
    if (isEnable && !this.subscribed) {
      this.subscribed = true;
      if (this.props.autoSubscribes) {
        this.props.autoSubscribes.forEach((id) => this._socket.emit("subscribeObjects", id));
      }
      Object.keys(this.objectsSubscribes).forEach((id) => this._socket.emit("subscribeObjects", id));
      this.props.autoSubscribeLog && this._socket.emit("requireLog", true);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("subscribe", id));
      Object.keys(this.filesSubscribes).forEach((key) => {
        const [id, filePattern] = key.split("$%$");
        this._socket.emit("subscribeFiles", id, filePattern);
      });
    } else if (!isEnable && this.subscribed) {
      this.subscribed = false;
      if (this.props.autoSubscribes) {
        this.props.autoSubscribes.forEach((id) => this._socket.emit("unsubscribeObjects", id));
      }
      Object.keys(this.objectsSubscribes).forEach((id) => this._socket.emit("unsubscribeObjects", id));
      this.props.autoSubscribeLog && this._socket.emit("requireLog", false);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("unsubscribe", id));
      Object.keys(this.filesSubscribes).forEach((key) => {
        const [id, filePattern] = key.split("$%$");
        this._socket.emit("unsubscribeFiles", id, filePattern);
      });
    }
  }
  requireLog(isEnabled) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("requireLog", isEnabled, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  delObject(id, maintenance = false) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("delObject", id, { maintenance }, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  delObjects(id, maintenance) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("delObjects", id, { maintenance }, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  setObject(id, obj) {
    if (!obj) {
      return Promise.reject("Null object is not allowed");
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("setObject", id, obj, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getObject(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (id && id === this.ignoreState) {
          resolve({
            _id: this.ignoreState,
            type: "state",
            common: {
              name: "ignored state",
              type: "mixed"
            }
          });
          return;
        }
        this._socket.emit("getObject", id, (err, obj) => {
          if (err)
            reject(err);
          resolve(obj);
        });
      }
    });
  }
  sendTo(instance, command, data) {
    return this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("sendTo", instance, command, data, (result) => {
          resolve(result);
        });
      }
    });
  }
  extendObject(id, obj) {
    if (!obj) {
      return Promise.reject("Null object is not allowed");
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("extendObject", id, obj, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  registerLogHandler(handler) {
    if (!this.onLogHandlers.includes(handler)) {
      this.onLogHandlers.push(handler);
    }
  }
  unregisterLogHandler(handler) {
    const pos = this.onLogHandlers.indexOf(handler);
    pos !== -1 && this.onLogHandlers.splice(pos, 1);
  }
  registerConnectionHandler(handler) {
    if (!this.onConnectionHandlers.includes(handler)) {
      this.onConnectionHandlers.push(handler);
    }
  }
  unregisterConnectionHandler(handler) {
    const pos = this.onConnectionHandlers.indexOf(handler);
    pos !== -1 && this.onConnectionHandlers.splice(pos, 1);
  }
  registerCmdStdoutHandler(handler) {
    this.onCmdStdoutHandler = handler;
  }
  unregisterCmdStdoutHandler() {
    this.onCmdStdoutHandler = void 0;
  }
  registerCmdStderrHandler(handler) {
    this.onCmdStderrHandler = handler;
  }
  unregisterCmdStderrHandler() {
    this.onCmdStderrHandler = void 0;
  }
  registerCmdExitHandler(handler) {
    this.onCmdExitHandler = handler;
  }
  unregisterCmdExitHandler() {
    this.onCmdExitHandler = void 0;
  }
  getEnums(_enum, update) {
    return this.request({
      cacheKey: `enums_${_enum || "all"}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "enum", {
          startkey: `enum.${_enum || ""}`,
          endkey: _enum ? `enum.${_enum}.\u9999` : `enum.\u9999`
        }, (err, res) => {
          if (err)
            reject(err);
          const _res = {};
          if (res) {
            for (let i = 0; i < res.rows.length; i++) {
              if (_enum && res.rows[i].id === `enum.${_enum}`) {
                continue;
              }
              _res[res.rows[i].id] = res.rows[i].value;
            }
          }
          resolve(_res);
        });
      }
    });
  }
  getObjectView(start, end, type) {
    return this.getObjectViewCustom("system", type, start, end);
  }
  getObjectViewSystem(type, start, end) {
    return this.getObjectViewCustom("system", type, start, end);
  }
  getObjectViewCustom(design, type, start, end) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        start = start || "";
        end = end || "\u9999";
        this._socket.emit("getObjectView", design, type, { startkey: start, endkey: end }, (err, res) => {
          if (err)
            reject(err);
          const _res = {};
          if (res && res.rows) {
            for (let i = 0; i < res.rows.length; i++) {
              _res[res.rows[i].id] = res.rows[i].value;
            }
          }
          resolve(_res);
        });
      }
    });
  }
  readMetaItems() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "meta", { startkey: "", endkey: "\u9999" }, (err, objs) => {
          var _a;
          if (err)
            reject(err);
          resolve((_a = objs.rows) === null || _a === void 0 ? void 0 : _a.map((obj) => obj.value).filter((val) => !!val));
        });
      }
    });
  }
  readDir(adapterName, path) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("readDir", adapterName, path, (err, files) => {
          if (err)
            reject(err);
          resolve(files);
        });
      }
    });
  }
  readFile(adapterName, fileName, base64) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit(base64 ? "readFile64" : "readFile", adapterName, fileName, (err, data, type) => {
          if (err)
            reject(err);
          resolve({ file: data, mimeType: type });
        });
      }
    });
  }
  writeFile64(adapter, fileName, data) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (typeof data === "string") {
          this._socket.emit("writeFile", adapter, fileName, data, (err) => {
            if (err)
              reject(err);
            resolve();
          });
        } else {
          const base64 = btoa(new Uint8Array(data).reduce((data2, byte) => data2 + String.fromCharCode(byte), ""));
          this._socket.emit("writeFile64", adapter, fileName, base64, (err) => {
            if (err)
              reject(err);
            resolve();
          });
        }
      }
    });
  }
  deleteFile(adapter, fileName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFile", adapter, fileName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  deleteFolder(adapter, folderName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFolder", adapter, folderName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  rename(adapter, oldName, newName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("rename", adapter, oldName, newName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  renameFile(adapter, oldName, newName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("renameFile", adapter, oldName, newName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  cmdExec(host, cmd, cmdId, cmdTimeout) {
    return this.request({
      commandTimeout: cmdTimeout,
      executor: (resolve, reject, timeout) => {
        host = (0, import_tools.normalizeHostId)(host);
        this._socket.emit("cmdExec", host, cmdId, cmd, (err) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfig",
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a, _b, _c;
        var _d, _e;
        let systemConfig = await this.getObject("system.config");
        (_a = systemConfig) !== null && _a !== void 0 ? _a : systemConfig = {};
        (_b = (_d = systemConfig).common) !== null && _b !== void 0 ? _b : _d.common = {};
        (_c = (_e = systemConfig).native) !== null && _c !== void 0 ? _c : _e.native = {};
        resolve(systemConfig);
      }
    });
  }
  getCompactSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfigCommon",
      forceUpdate: update,
      commandTimeout: false,
      requireAdmin: true,
      executor: (resolve, reject) => {
        this._socket.emit("getCompactSystemConfig", (err, systemConfig) => {
          var _a, _b, _c;
          var _d, _e;
          if (err)
            reject(err);
          (_a = systemConfig) !== null && _a !== void 0 ? _a : systemConfig = {};
          (_b = (_d = systemConfig).common) !== null && _b !== void 0 ? _b : _d.common = {};
          (_c = (_e = systemConfig).native) !== null && _c !== void 0 ? _c : _e.native = {};
          resolve(systemConfig);
        });
      }
    });
  }
  getForeignStates(pattern) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getForeignStates", pattern || "*", (err, states) => {
          if (err)
            reject(err);
          resolve(states !== null && states !== void 0 ? states : {});
        });
      }
    });
  }
  getForeignObjects(pattern, type) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getForeignObjects", pattern || "*", type, (err, objects) => {
          if (err)
            reject(err);
          resolve(objects);
        });
      }
    });
  }
  setSystemConfig(obj) {
    return this.setObject("system.config", obj);
  }
  getRawSocket() {
    return this._socket;
  }
  getHistory(id, options) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values) => {
          if (err)
            reject(err);
          resolve(values);
        });
      }
    });
  }
  getHistoryEx(id, options) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values, stepIgnore, sessionId) => {
          if (err)
            reject(err);
          resolve({
            values,
            sessionId,
            stepIgnore
          });
        });
      }
    });
  }
  getIpAddresses(host, update) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `IPs_${host}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject(host);
        resolve((_a = obj === null || obj === void 0 ? void 0 : obj.common.address) !== null && _a !== void 0 ? _a : []);
      }
    });
  }
  getVersion(update) {
    return this.request({
      cacheKey: "version",
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getVersion", (err, version, serverName) => {
          if (err && !version && typeof err === "string" && err.match(/\d+\.\d+\.\d+/)) {
            resolve({ version: err, serverName: "socketio" });
          } else {
            if (err)
              reject(err);
            resolve({ version, serverName });
          }
        });
      }
    });
  }
  getWebServerName() {
    return this.request({
      cacheKey: "webName",
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getAdapterName", (err, name) => {
          if (err)
            reject(err);
          resolve(name);
        });
      }
    });
  }
  fileExists(adapter, filename) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("fileExists", adapter, filename, (err, exists) => {
          if (err)
            reject(err);
          resolve(!!exists);
        });
      }
    });
  }
  getCurrentUser() {
    return this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("authEnabled", (_isSecure, user) => {
          resolve(user);
        });
      }
    });
  }
  getUuid() {
    return this.request({
      cacheKey: "uuid",
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject("system.meta.uuid");
        resolve((_a = obj === null || obj === void 0 ? void 0 : obj.native) === null || _a === void 0 ? void 0 : _a.uuid);
      }
    });
  }
  checkFeatureSupported(feature, update) {
    return this.request({
      cacheKey: `supportedFeatures_${feature}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("checkFeatureSupported", feature, (err, features) => {
          if (err)
            reject(err);
          resolve(features);
        });
      }
    });
  }
  getAdapterInstances(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter || "";
    return this.request({
      cacheKey: `instances_${adapter}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        const startKey = adapter ? `system.adapter.${adapter}.` : "system.adapter.";
        const endKey = `${startKey}\u9999`;
        const instances = await this.getObjectViewSystem("instance", startKey, endKey);
        const instanceObjects = Object.values(instances);
        if (adapter) {
          resolve(instanceObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(instanceObjects);
        }
      }
    });
  }
  getAdapters(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter || "";
    return this.request({
      cacheKey: `adapter_${adapter}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        const adapters = await this.getObjectViewSystem("adapter", `system.adapter.${adapter || ""}`, `system.adapter.${adapter || "\u9999"}`);
        const adapterObjects = Object.values(adapters);
        if (adapter) {
          resolve(adapterObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(adapterObjects);
        }
      }
    });
  }
  getGroups(update) {
    return this.request({
      cacheKey: "groups",
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "group", {
          startkey: "system.group.",
          endkey: "system.group.\u9999"
        }, (err, doc) => {
          if (err) {
            reject(err);
          } else {
            resolve((0, import_tools.getObjectViewResultToArray)(doc));
          }
        });
      }
    });
  }
  logout() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("logout", (err) => {
          err ? reject(err) : resolve(null);
        });
      }
    });
  }
  subscribeOnInstance(targetInstance, messageType, data, callback) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("clientSubscribe", targetInstance, messageType, data, (err, subscribeResult) => {
          if (err) {
            reject(err);
          } else if (subscribeResult) {
            if (subscribeResult.error) {
              reject(subscribeResult.error);
            } else {
              if (!targetInstance.startsWith("system.adapter.")) {
                targetInstance = `system.adapter.${targetInstance}`;
              }
              this._instanceSubscriptions[targetInstance] = this._instanceSubscriptions[targetInstance] || [];
              if (!this._instanceSubscriptions[targetInstance].find((subscription) => subscription.messageType === messageType && subscription.callback === callback)) {
                this._instanceSubscriptions[targetInstance].push({
                  messageType,
                  callback
                });
              }
            }
          }
        });
      }
    });
  }
  unsubscribeFromInstance(targetInstance, messageType, callback) {
    var _a;
    if (!targetInstance.startsWith("system.adapter.")) {
      targetInstance = `system.adapter.${targetInstance}`;
    }
    let deleted;
    const promiseResults = [];
    do {
      deleted = false;
      const index = (_a = this._instanceSubscriptions[targetInstance]) === null || _a === void 0 ? void 0 : _a.findIndex((sub) => (!messageType || sub.messageType === messageType) && (!callback || sub.callback === callback));
      if (index !== void 0 && index !== null && index !== -1) {
        deleted = true;
        const _messageType = this._instanceSubscriptions[targetInstance][index].messageType;
        this._instanceSubscriptions[targetInstance].splice(index, 1);
        if (!this._instanceSubscriptions[targetInstance].length) {
          delete this._instanceSubscriptions[targetInstance];
        }
        const found = this._instanceSubscriptions[targetInstance] && this._instanceSubscriptions[targetInstance].find((sub) => sub.messageType === _messageType);
        if (!found) {
          promiseResults.push(this.request({
            commandTimeout: false,
            executor: (resolve, reject) => {
              this._socket.emit("clientUnsubscribe", targetInstance, messageType, (err, wasSubscribed) => err ? reject(err) : resolve(wasSubscribed));
            }
          }));
        }
      }
    } while (deleted && (!callback || !messageType));
    if (promiseResults.length) {
      return Promise.all(promiseResults).then((results) => !!results.find((result) => result));
    }
    return Promise.resolve(false);
  }
  log(text, level) {
    return text ? this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("log", text, level);
        return resolve(null);
      }
    }) : Promise.resolve(null);
  }
  setStateToIgnore(id) {
    this.ignoreState = id;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Connection,
  ERRORS,
  NOT_CONNECTED,
  PERMISSION_ERROR,
  PROGRESS
});
//# sourceMappingURL=Connection.js.map
