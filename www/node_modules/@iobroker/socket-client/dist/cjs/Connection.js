var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  Connection: () => Connection,
  ERRORS: () => ERRORS,
  NOT_CONNECTED: () => NOT_CONNECTED,
  PERMISSION_ERROR: () => PERMISSION_ERROR,
  PROGRESS: () => PROGRESS
});
var import_DeferredPromise = __toModule(require("./DeferredPromise.js"));
var import_tools = __toModule(require("./tools.js"));
var PROGRESS;
(function(PROGRESS2) {
  PROGRESS2[PROGRESS2["CONNECTING"] = 0] = "CONNECTING";
  PROGRESS2[PROGRESS2["CONNECTED"] = 1] = "CONNECTED";
  PROGRESS2[PROGRESS2["OBJECTS_LOADED"] = 2] = "OBJECTS_LOADED";
  PROGRESS2[PROGRESS2["READY"] = 3] = "READY";
})(PROGRESS || (PROGRESS = {}));
var ERRORS;
(function(ERRORS2) {
  ERRORS2["PERMISSION_ERROR"] = "permissionError";
  ERRORS2["NOT_CONNECTED"] = "notConnectedError";
  ERRORS2["TIMEOUT"] = "timeout";
  ERRORS2["NOT_ADMIN"] = "Allowed only in admin";
  ERRORS2["NOT_SUPPORTED"] = "Not supported";
})(ERRORS || (ERRORS = {}));
const PERMISSION_ERROR = ERRORS.PERMISSION_ERROR;
const NOT_CONNECTED = ERRORS.NOT_CONNECTED;
class Connection {
  constructor(props) {
    this.connected = false;
    this.subscribed = false;
    this.firstConnect = true;
    this.waitForRestart = false;
    this.loaded = false;
    this.statesSubscribes = {};
    this.objectsSubscribes = {};
    this.objects = {};
    this.states = {};
    this.acl = null;
    this.isSecure = false;
    this.onConnectionHandlers = [];
    this.onLogHandlers = [];
    this._waitForFirstConnectionPromise = (0, import_DeferredPromise.createDeferredPromise)();
    this._promises = {};
    this._systemLang = "en";
    this.props = this.applyDefaultProps(props);
    this.waitForSocketLib().then(() => this.startSocket()).catch((e) => {
      alert(`Socket connection could not be initialized: ${e}`);
    });
  }
  applyDefaultProps(props) {
    var _a, _b, _c, _d;
    return __spreadProps(__spreadValues({}, props), {
      protocol: props.protocol || window.location.protocol,
      host: props.host || window.location.hostname,
      port: props.port || (window.location.port === "3000" ? 8081 : window.location.port),
      ioTimeout: Math.max(props.ioTimeout || 2e4, 2e4),
      cmdTimeout: Math.max(props.cmdTimeout || 5e3, 5e3),
      admin5only: props.admin5only || false,
      autoSubscribes: (_a = props.autoSubscribes) !== null && _a !== void 0 ? _a : [],
      autoSubscribeLog: (_b = props.autoSubscribeLog) !== null && _b !== void 0 ? _b : false,
      doNotLoadACL: (_c = props.doNotLoadACL) !== null && _c !== void 0 ? _c : true,
      doNotLoadAllObjects: (_d = props.doNotLoadAllObjects) !== null && _d !== void 0 ? _d : true
    });
  }
  onError(error) {
    var _a;
    ((_a = this.props.onError) !== null && _a !== void 0 ? _a : console.error)(error);
  }
  get systemConfig() {
    return this._systemConfig;
  }
  get systemLang() {
    return this._systemLang;
  }
  static isWeb() {
    return window.socketUrl !== void 0;
  }
  waitForSocketLib() {
    if (this._waitForSocketPromise)
      return this._waitForSocketPromise;
    this._waitForSocketPromise = new Promise(async (resolve, reject) => {
      if (typeof window.io === "undefined") {
        if (typeof window.registerSocketOnLoad === "function") {
          window.registerSocketOnLoad(() => resolve());
        } else {
          for (let i = 1; i <= 30; i++) {
            if (window.io)
              return resolve();
            await (0, import_tools.wait)(100);
          }
          reject(new Error("Socket library could not be loaded!"));
        }
      } else {
        resolve();
      }
    });
    return this._waitForSocketPromise;
  }
  async startSocket() {
    if (this._socket)
      return;
    let host = this.props.host;
    let port = this.props.port;
    let protocol = this.props.protocol.replace(":", "");
    if (window.socketUrl) {
      const parsed = new URL(window.socketUrl);
      host = parsed.hostname;
      port = parsed.port;
      protocol = parsed.protocol.replace(":", "");
    }
    const url = `${protocol}://${host}:${port}`;
    this._socket = window.io.connect(url, {
      query: protocol == "ws" || protocol == "wss" ? "ws=true" : "",
      name: this.props.name,
      timeout: this.props.ioTimeout
    });
    this._socket.on("connect", (noTimeout) => {
      if (noTimeout !== true) {
        this.connected = true;
        setTimeout(() => this.getVersion().then((info) => {
          const [major, minor, patch] = info.version.split(".");
          const v = parseInt(major, 10) * 1e4 + parseInt(minor, 10) * 100 + parseInt(patch, 10);
          if (v < 40102) {
            this._authTimer = null;
            this.onPreConnect(false, false);
          } else {
            this._socket.emit("authenticate", (isOk, isSecure) => this.onPreConnect(isOk, isSecure));
          }
        }), 500);
      } else {
        this._socket.emit("authenticate", (isOk, isSecure) => {
          this.onPreConnect(isOk, isSecure);
        });
      }
    });
    this._socket.on("reconnect", () => {
      var _a, _b;
      (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.READY);
      this.connected = true;
      if (this.waitForRestart) {
        window.location.reload();
      } else {
        this._subscribe(true);
        this.onConnectionHandlers.forEach((cb) => cb(true));
      }
    });
    this._socket.on("disconnect", () => {
      var _a, _b;
      this.connected = false;
      this.subscribed = false;
      (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.CONNECTING);
      this.onConnectionHandlers.forEach((cb) => cb(false));
    });
    this._socket.on("reauthenticate", () => this.authenticate());
    this._socket.on("log", (message) => {
      var _a, _b;
      (_b = (_a = this.props).onLog) === null || _b === void 0 ? void 0 : _b.call(_a, message);
      this.onLogHandlers.forEach((cb) => cb(message));
    });
    this._socket.on("error", (err) => {
      let _err;
      if (err == void 0) {
        _err = "";
      } else if (typeof err.toString === "function") {
        _err = err.toString();
      } else {
        _err = JSON.stringify(err);
        console.error(`Received strange error: ${_err}`);
      }
      if (_err.includes("User not authorized")) {
        this.authenticate();
      } else {
        window.alert(`Socket Error: ${err}`);
      }
    });
    this._socket.on("connect_error", (err) => console.error(`Connect error: ${err}`));
    this._socket.on("permissionError", (err) => this.onError({
      message: "no permission",
      operation: err.operation,
      type: err.type,
      id: err.id || ""
    }));
    this._socket.on("objectChange", (id, obj) => {
      setTimeout(() => this.objectChange(id, obj), 0);
    });
    this._socket.on("stateChange", (id, state) => {
      setTimeout(() => this.stateChange(id, state), 0);
    });
    this._socket.on("cmdStdout", (id, text) => {
      var _a;
      (_a = this.onCmdStdoutHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, text);
    });
    this._socket.on("cmdStderr", (id, text) => {
      var _a;
      (_a = this.onCmdStderrHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, text);
    });
    this._socket.on("cmdExit", (id, exitCode) => {
      var _a;
      (_a = this.onCmdExitHandler) === null || _a === void 0 ? void 0 : _a.call(this, id, exitCode);
    });
  }
  onPreConnect(isOk, isSecure) {
    var _a, _b;
    if (this._authTimer) {
      clearTimeout(this._authTimer);
      this._authTimer = null;
    }
    this.connected = true;
    this.isSecure = isSecure;
    if (this.waitForRestart) {
      window.location.reload();
    } else {
      if (this.firstConnect) {
        this.loadData();
      } else {
        (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.READY);
      }
      this._subscribe(true);
      this.onConnectionHandlers.forEach((cb) => cb(true));
    }
    this._waitForFirstConnectionPromise.resolve();
  }
  isConnected() {
    return this.connected;
  }
  waitForFirstConnection() {
    return this._waitForFirstConnectionPromise;
  }
  async getUserPermissions() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getUserPermissions", (err, acl) => {
          if (err)
            reject(err);
          resolve(acl);
        });
      }
    });
  }
  async loadData() {
    if (this.loaded)
      return;
    const maxAttempts = 10;
    for (let i = 1; i <= maxAttempts; i++) {
      this.doLoadData();
      if (this.loaded)
        return;
      await (0, import_tools.wait)(1e3);
    }
  }
  async doLoadData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (this.loaded)
      return;
    if (!this.props.doNotLoadACL) {
      try {
        this.acl = await this.getUserPermissions();
      } catch (e) {
        this.onError(`Cannot read user permissions: ${e}`);
        return;
      }
    }
    try {
      if (this.props.admin5only && !Connection.isWeb() && (!window.vendorPrefix || window.vendorPrefix === "@@vendorPrefix@@")) {
        this._systemConfig = await this.getCompactSystemConfig();
      } else {
        this._systemConfig = await this.getSystemConfig();
      }
    } catch (e) {
      this.onError(`Cannot read system config: ${e}`);
      return;
    }
    this._systemLang = (_a = this._systemConfig.common) === null || _a === void 0 ? void 0 : _a.language;
    if (!this._systemLang) {
      this._systemLang = window.navigator.userLanguage || window.navigator.language;
      if (/^(en|de|ru|pt|nl|fr|it|es|pl)\-?/.test(this._systemLang)) {
        this._systemLang = this._systemLang.substr(0, 2);
      } else if (!/^(en|de|ru|pt|nl|fr|it|es|pl|zh-cn)$/.test(this._systemLang)) {
        this._systemLang = "en";
      }
      this._systemConfig.common.language = this._systemLang;
    }
    (_c = (_b = this.props).onLanguage) === null || _c === void 0 ? void 0 : _c.call(_b, this.systemLang);
    this.loaded = true;
    (_e = (_d = this.props).onProgress) === null || _e === void 0 ? void 0 : _e.call(_d, PROGRESS.CONNECTED);
    this.firstConnect = false;
    if (!this.props.doNotLoadAllObjects) {
      this.objects = await this.getObjects();
    } else if (this.props.admin5only) {
      this.objects = {};
    } else {
      this.objects = { "system.config": this._systemConfig };
    }
    (_g = (_f = this.props).onProgress) === null || _g === void 0 ? void 0 : _g.call(_f, PROGRESS.READY);
    (_j = (_h = this.props).onReady) === null || _j === void 0 ? void 0 : _j.call(_h, this.objects);
  }
  authenticate() {
    if (window.location.search.includes("&href=")) {
      window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;
    } else {
      window.location.href = `${window.location.protocol}//${window.location.host}${window.location.pathname}?login&href=${window.location.search}${window.location.hash}`;
    }
  }
  async subscribeState(...args) {
    let id;
    let binary;
    let cb;
    if (args.length === 3) {
      [id, binary, cb] = args;
    } else {
      [id, cb] = args;
      binary = false;
    }
    if (typeof cb !== "function") {
      throw new Error("The state change handler must be a function!");
    }
    if (!this.statesSubscribes[id]) {
      this.statesSubscribes[id] = {
        reg: new RegExp((0, import_tools.pattern2RegEx)(id)),
        cbs: [cb]
      };
      if (this.connected)
        this._socket.emit("subscribe", id);
    } else {
      !this.statesSubscribes[id].cbs.includes(cb) && this.statesSubscribes[id].cbs.push(cb);
    }
    if (this.connected) {
      if (binary) {
        let base64;
        try {
          base64 = await this.getBinaryState(id);
        } catch (e) {
          console.error(`Cannot getBinaryState "${id}": ${JSON.stringify(e)}`);
        }
        if (base64 != void 0) {
          cb(id, base64);
        }
      } else {
        let states;
        try {
          states = await this.getForeignStates(id);
        } catch (e) {
          console.error(`Cannot getForeignStates "${id}": ${JSON.stringify(e)}`);
          return;
        }
        if (states) {
          for (const [id2, state] of Object.entries(states)) {
            cb(id2, state);
          }
        }
      }
    }
  }
  unsubscribeState(id, cb) {
    if (this.statesSubscribes[id]) {
      const sub = this.statesSubscribes[id];
      if (cb) {
        const pos = sub.cbs.indexOf(cb);
        pos !== -1 && sub.cbs.splice(pos, 1);
      } else {
        sub.cbs = [];
      }
      if (!sub.cbs || !sub.cbs.length) {
        delete this.statesSubscribes[id];
        this.connected && this._socket.emit("unsubscribe", id);
      }
    }
  }
  subscribeObject(id, cb) {
    if (!this.objectsSubscribes[id]) {
      this.objectsSubscribes[id] = {
        reg: new RegExp((0, import_tools.pattern2RegEx)(id)),
        cbs: [cb]
      };
      this.connected && this._socket.emit("subscribeObjects", id);
    } else {
      !this.objectsSubscribes[id].cbs.includes(cb) && this.objectsSubscribes[id].cbs.push(cb);
    }
    return Promise.resolve();
  }
  unsubscribeObject(id, cb) {
    if (this.objectsSubscribes[id]) {
      const sub = this.objectsSubscribes[id];
      if (cb) {
        const pos = sub.cbs.indexOf(cb);
        pos !== -1 && sub.cbs.splice(pos, 1);
      } else {
        sub.cbs = [];
      }
      if (this.connected && (!sub.cbs || !sub.cbs.length)) {
        delete this.objectsSubscribes[id];
        this.connected && this._socket.emit("unsubscribeObjects", id);
      }
    }
    return Promise.resolve();
  }
  objectChange(id, obj) {
    var _a, _b;
    let oldObj;
    if (this.objects[id]) {
      oldObj = { _id: id, type: this.objects[id].type };
    }
    let changed = false;
    if (obj) {
      if (obj._rev && this.objects[id]) {
        this.objects[id]._rev = obj._rev;
      }
      if (!this.objects[id] || JSON.stringify(this.objects[id]) !== JSON.stringify(obj)) {
        this.objects[id] = obj;
        changed = true;
      }
    } else if (this.objects[id]) {
      delete this.objects[id];
      changed = true;
    }
    for (const [_id, sub] of Object.entries(this.objectsSubscribes)) {
      if (_id === id || sub.reg.test(id)) {
        sub.cbs.forEach((cb) => cb(id, obj, oldObj));
      }
    }
    if (changed)
      (_b = (_a = this.props).onObjectChange) === null || _b === void 0 ? void 0 : _b.call(_a, id, obj);
  }
  stateChange(id, state) {
    for (const sub of Object.values(this.statesSubscribes)) {
      if (sub.reg.test(id)) {
        for (const cb of sub.cbs) {
          cb(id, state !== null && state !== void 0 ? state : null);
        }
      }
    }
  }
  async request({
    cacheKey,
    forceUpdate,
    commandTimeout,
    onTimeout,
    requireAdmin,
    requireFeatures,
    executor
  }) {
    if (requireAdmin && Connection.isWeb()) {
      return Promise.reject(ERRORS.NOT_ADMIN);
    }
    if (cacheKey && !forceUpdate && cacheKey in this._promises) {
      return this._promises[cacheKey];
    }
    if (!this.connected) {
      return Promise.reject(ERRORS.NOT_CONNECTED);
    }
    if (requireFeatures === null || requireFeatures === void 0 ? void 0 : requireFeatures.length) {
      for (const feature of requireFeatures) {
        if (!await this.checkFeatureSupported(feature)) {
          throw ERRORS.NOT_SUPPORTED;
        }
      }
    }
    const promise = new Promise(async (resolve, reject) => {
      const timeoutControl = {
        elapsed: false,
        clearTimeout: () => {
        }
      };
      let timeout;
      if (commandTimeout !== false) {
        timeout = setTimeout(() => {
          timeoutControl.elapsed = true;
          onTimeout === null || onTimeout === void 0 ? void 0 : onTimeout();
          reject(ERRORS.TIMEOUT);
        }, commandTimeout !== null && commandTimeout !== void 0 ? commandTimeout : this.props.cmdTimeout);
        timeoutControl.clearTimeout = () => {
          clearTimeout(timeout);
        };
      }
      try {
        await executor(resolve, reject, timeoutControl);
      } catch (e) {
        reject(e);
      }
    });
    if (cacheKey) {
      this._promises[cacheKey] = promise;
    }
    return promise;
  }
  getStates() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getStates", (err, res) => {
          this.states = res !== null && res !== void 0 ? res : {};
          if (err)
            reject(err);
          resolve(this.states);
        });
      }
    });
  }
  getState(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getState", id, (err, state) => {
          if (err)
            reject(err);
          resolve(state);
        });
      }
    });
  }
  getBinaryState(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getBinaryState", id, (err, state) => {
          if (err)
            reject(err);
          resolve(state);
        });
      }
    });
  }
  setBinaryState(id, base64) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("setBinaryState", id, base64, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  setState(id, val) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("setState", id, val, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getObjects(update, disableProgressUpdate) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (!update && this.objects) {
          resolve(this.objects);
          return;
        }
        this._socket.emit(Connection.isWeb() ? "getObjects" : "getAllObjects", (err, res) => {
          var _a, _b;
          if (!disableProgressUpdate)
            (_b = (_a = this.props).onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, PROGRESS.OBJECTS_LOADED);
          if (err)
            reject(err);
          this.objects = res !== null && res !== void 0 ? res : {};
          resolve(this.objects);
        });
      }
    });
  }
  _subscribe(isEnable) {
    if (isEnable && !this.subscribed) {
      this.subscribed = true;
      if (this.props.autoSubscribes) {
        this.props.autoSubscribes.forEach((id) => this._socket.emit("subscribeObjects", id));
      }
      Object.keys(this.objectsSubscribes).forEach((id) => this._socket.emit("subscribeObjects", id));
      this.props.autoSubscribeLog && this._socket.emit("requireLog", true);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("subscribe", id));
    } else if (!isEnable && this.subscribed) {
      this.subscribed = false;
      if (this.props.autoSubscribes) {
        this.props.autoSubscribes.forEach((id) => this._socket.emit("unsubscribeObjects", id));
      }
      Object.keys(this.objectsSubscribes).forEach((id) => this._socket.emit("unsubscribeObjects", id));
      this.props.autoSubscribeLog && this._socket.emit("requireLog", false);
      Object.keys(this.statesSubscribes).forEach((id) => this._socket.emit("unsubscribe", id));
    }
  }
  requireLog(isEnabled) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("requireLog", isEnabled, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  delObject(id, maintenance = false) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("delObject", id, { maintenance }, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  delObjects(id, maintenance) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("delObjects", id, { maintenance }, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  setObject(id, obj) {
    if (!obj) {
      return Promise.reject("Null object is not allowed");
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("setObject", id, obj, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getObject(id) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObject", id, (err, obj) => {
          if (err)
            reject(err);
          resolve(obj);
        });
      }
    });
  }
  sendTo(instance, command, data) {
    return this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("sendTo", instance, command, data, (result) => {
          resolve(result);
        });
      }
    });
  }
  extendObject(id, obj) {
    if (!obj) {
      return Promise.reject("Null object is not allowed");
    }
    obj = JSON.parse(JSON.stringify(obj));
    delete obj.from;
    delete obj.user;
    delete obj.ts;
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("extendObject", id, obj, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  registerLogHandler(handler) {
    if (!this.onLogHandlers.includes(handler)) {
      this.onLogHandlers.push(handler);
    }
  }
  unregisterLogHandler(handler) {
    const pos = this.onLogHandlers.indexOf(handler);
    pos !== -1 && this.onLogHandlers.splice(pos, 1);
  }
  registerConnectionHandler(handler) {
    if (!this.onConnectionHandlers.includes(handler)) {
      this.onConnectionHandlers.push(handler);
    }
  }
  unregisterConnectionHandler(handler) {
    const pos = this.onConnectionHandlers.indexOf(handler);
    pos !== -1 && this.onConnectionHandlers.splice(pos, 1);
  }
  registerCmdStdoutHandler(handler) {
    this.onCmdStdoutHandler = handler;
  }
  unregisterCmdStdoutHandler() {
    this.onCmdStdoutHandler = void 0;
  }
  registerCmdStderrHandler(handler) {
    this.onCmdStderrHandler = handler;
  }
  unregisterCmdStderrHandler() {
    this.onCmdStderrHandler = void 0;
  }
  registerCmdExitHandler(handler) {
    this.onCmdExitHandler = handler;
  }
  unregisterCmdExitHandler() {
    this.onCmdExitHandler = void 0;
  }
  getEnums(_enum, update) {
    return this.request({
      cacheKey: `enums_${_enum || "all"}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "enum", {
          startkey: `enum.${_enum || ""}`,
          endkey: _enum ? `enum.${_enum}.\u9999` : `enum.\u9999`
        }, (err, res) => {
          if (err)
            reject(err);
          const _res = {};
          if (res) {
            for (let i = 0; i < res.rows.length; i++) {
              if (_enum && res.rows[i].id === `enum.${_enum}`) {
                continue;
              }
              _res[res.rows[i].id] = res.rows[i].value;
            }
          }
          resolve(_res);
        });
      }
    });
  }
  getObjectView(start, end, type) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        start = start || "";
        end = end || "\u9999";
        this._socket.emit("getObjectView", "system", type, { startkey: start, endkey: end }, (err, res) => {
          if (err)
            reject(err);
          const _res = {};
          if (res && res.rows) {
            for (let i = 0; i < res.rows.length; i++) {
              _res[res.rows[i].id] = res.rows[i].value;
            }
          }
          resolve(_res);
        });
      }
    });
  }
  readMetaItems() {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getObjectView", "system", "meta", { startkey: "", endkey: "\u9999" }, (err, objs) => {
          var _a;
          if (err)
            reject(err);
          resolve((_a = objs.rows) === null || _a === void 0 ? void 0 : _a.map((obj) => obj.value).filter((val) => !!val));
        });
      }
    });
  }
  readDir(adapterName, path) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("readDir", adapterName, path, (err, files) => {
          if (err)
            reject(err);
          resolve(files);
        });
      }
    });
  }
  readFile(adapterName, fileName, base64) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit(base64 ? "readFile64" : "readFile", adapterName, fileName, (err, data, type) => {
          if (err)
            reject(err);
          resolve({ file: data, mimeType: type });
        });
      }
    });
  }
  writeFile64(adapter, fileName, data) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        if (typeof data === "string") {
          this._socket.emit("writeFile", adapter, fileName, data, (err) => {
            if (err)
              reject(err);
            resolve();
          });
        } else {
          const base64 = btoa(new Uint8Array(data).reduce((data2, byte) => data2 + String.fromCharCode(byte), ""));
          this._socket.emit("writeFile64", adapter, fileName, base64, (err) => {
            if (err)
              reject(err);
            resolve();
          });
        }
      }
    });
  }
  deleteFile(adapter, fileName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFile", adapter, fileName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  deleteFolder(adapter, folderName) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("deleteFolder", adapter, folderName, (err) => {
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  cmdExec(host, cmd, cmdId, cmdTimeout) {
    return this.request({
      commandTimeout: cmdTimeout,
      executor: (resolve, reject, timeout) => {
        host = (0, import_tools.normalizeHostId)(host);
        this._socket.emit("cmdExec", host, cmdId, cmd, (err) => {
          if (timeout.elapsed)
            return;
          timeout.clearTimeout();
          if (err)
            reject(err);
          resolve();
        });
      }
    });
  }
  getSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfig",
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a, _b, _c;
        var _d, _e;
        let systemConfig = await this.getObject("system.config");
        (_a = systemConfig) !== null && _a !== void 0 ? _a : systemConfig = {};
        (_b = (_d = systemConfig).common) !== null && _b !== void 0 ? _b : _d.common = {};
        (_c = (_e = systemConfig).native) !== null && _c !== void 0 ? _c : _e.native = {};
        resolve(systemConfig);
      }
    });
  }
  getCompactSystemConfig(update) {
    return this.request({
      cacheKey: "systemConfigCommon",
      forceUpdate: update,
      commandTimeout: false,
      requireAdmin: true,
      executor: (resolve, reject) => {
        this._socket.emit("getCompactSystemConfig", (err, systemConfig) => {
          var _a, _b, _c;
          var _d, _e;
          if (err)
            reject(err);
          (_a = systemConfig) !== null && _a !== void 0 ? _a : systemConfig = {};
          (_b = (_d = systemConfig).common) !== null && _b !== void 0 ? _b : _d.common = {};
          (_c = (_e = systemConfig).native) !== null && _c !== void 0 ? _c : _e.native = {};
          resolve(systemConfig);
        });
      }
    });
  }
  getForeignStates(pattern) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getForeignStates", pattern || "*", (err, states) => {
          if (err)
            reject(err);
          resolve(states !== null && states !== void 0 ? states : {});
        });
      }
    });
  }
  getForeignObjects(pattern, type) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getForeignObjects", pattern || "*", type, (err, objects) => {
          if (err)
            reject(err);
          resolve(objects);
        });
      }
    });
  }
  setSystemConfig(obj) {
    return this.setObject("system.config", obj);
  }
  getRawSocket() {
    return this._socket;
  }
  getHistory(id, options) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values) => {
          if (err)
            reject(err);
          resolve(values);
        });
      }
    });
  }
  getHistoryEx(id, options) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getHistory", id, options, (err, values, stepIgnore, sessionId) => {
          if (err)
            reject(err);
          resolve({
            values,
            sessionId,
            stepIgnore
          });
        });
      }
    });
  }
  getIpAddresses(host, update) {
    host = (0, import_tools.normalizeHostId)(host);
    return this.request({
      cacheKey: `IPs_${host}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject(host);
        resolve((_a = obj === null || obj === void 0 ? void 0 : obj.common.address) !== null && _a !== void 0 ? _a : []);
      }
    });
  }
  getVersion() {
    return this.request({
      cacheKey: "version",
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getVersion", (err, version, serverName) => {
          if (err && !version && typeof err === "string" && err.match(/\d+\.\d+\.\d+/)) {
            resolve({ version: err, serverName: "socketio" });
          } else {
            if (err)
              reject(err);
            resolve({ version, serverName });
          }
        });
      }
    });
  }
  getWebServerName() {
    return this.request({
      cacheKey: "webName",
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("getAdapterName", (err, name) => {
          if (err)
            reject(err);
          resolve(name);
        });
      }
    });
  }
  fileExists(adapter, filename) {
    return this.request({
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("fileExists", adapter, filename, (err, exists) => {
          if (err)
            reject(err);
          resolve(!!exists);
        });
      }
    });
  }
  getCurrentUser() {
    return this.request({
      commandTimeout: false,
      executor: (resolve) => {
        this._socket.emit("authEnabled", (_isSecure, user) => {
          resolve(user);
        });
      }
    });
  }
  getUuid() {
    return this.request({
      cacheKey: "uuid",
      commandTimeout: false,
      executor: async (resolve) => {
        var _a;
        const obj = await this.getObject("system.meta.uuid");
        resolve((_a = obj === null || obj === void 0 ? void 0 : obj.native) === null || _a === void 0 ? void 0 : _a.uuid);
      }
    });
  }
  checkFeatureSupported(feature, update) {
    return this.request({
      cacheKey: `supportedFeatures_${feature}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: (resolve, reject) => {
        this._socket.emit("checkFeatureSupported", feature, (err, features) => {
          if (err)
            reject(err);
          resolve(features);
        });
      }
    });
  }
  getAdapterInstances(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter || "";
    return this.request({
      cacheKey: `instances_${adapter}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        const startKey = adapter ? `system.adapter.${adapter}.` : "system.adapter.";
        const endKey = `${startKey}\u9999`;
        const instances = await this.getObjectView(startKey, endKey, "instance");
        const instanceObjects = Object.values(instances);
        if (adapter) {
          resolve(instanceObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(instanceObjects);
        }
      }
    });
  }
  getAdapters(adapter, update) {
    if (typeof adapter === "boolean") {
      update = adapter;
      adapter = "";
    }
    adapter = adapter || "";
    return this.request({
      cacheKey: `adapter_${adapter}`,
      forceUpdate: update,
      commandTimeout: false,
      executor: async (resolve) => {
        const adapters = await this.getObjectView(`system.adapter.${adapter || ""}`, `system.adapter.${adapter || "\u9999"}`, "adapter");
        const adapterObjects = Object.values(adapters);
        if (adapter) {
          resolve(adapterObjects.filter((o) => o.common.name === adapter));
        } else {
          resolve(adapterObjects);
        }
      }
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Connection,
  ERRORS,
  NOT_CONNECTED,
  PERMISSION_ERROR,
  PROGRESS
});
//# sourceMappingURL=Connection.js.map
