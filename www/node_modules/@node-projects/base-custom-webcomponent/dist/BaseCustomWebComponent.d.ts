export declare const html: (strings: TemplateStringsArray, ...values: any[]) => HTMLTemplateElement;
export declare const htmlFromString: (value: string) => HTMLTemplateElement;
export declare const css: (strings: TemplateStringsArray, ...values: any[]) => CSSStyleSheet;
export declare const cssFromString: (value: string) => CSSStyleSheet;
export declare const cssAsync: (strings: TemplateStringsArray, ...values: any[]) => Promise<CSSStyleSheet>;
declare type propertySimpleDefinition = Object | BooleanConstructor | DateConstructor | NumberConstructor | StringConstructor | ArrayConstructor | ObjectConstructor;
declare type propertyComplexDefinition = {
    type: propertySimpleDefinition;
};
declare type propertyDefinition = propertyComplexDefinition | propertySimpleDefinition;
export declare function property(par?: propertyDefinition): (target: Object, propertyKey: PropertyKey) => void;
export declare function customElement(tagname: string): (class_: new (...par: any[]) => BaseCustomWebComponentNoAttachedTemplate) => void;
export declare class BaseCustomWebComponentNoAttachedTemplate extends HTMLElement {
    static readonly style: CSSStyleSheet | Promise<CSSStyleSheet>;
    static readonly template: HTMLTemplateElement;
    protected _bindings: ((firstRun?: boolean) => void)[];
    protected _repeatWeakMap: WeakMap<any, Element[]>;
    private static _bindingRegex;
    protected _getDomElement<T extends Element>(id: string): T;
    protected _getDomElements<T extends Element>(selector: string): T[];
    protected _assignEvents(node?: Node): void;
    /**
     * Parses Polymer like Bindings
     *
     * use [[expression]] for one way bindings
     *
     * use {{this.property::change;paste}} for two way wich binds to events 'change 'and 'paste'
     *
     * use @eventname="eventHandler" to bind a handler to a event
     * or @eventname="[[this.eventHandler(par1, par2, ..)]]" for complexer event logic
     * use @touch:contextmenu... for a context menu that also works with long press on touch
     *
     * use css:cssPropertyName=[[expression]] to bind to a css property
     *
     * use class:className=[[boolExpression]] to set/remove a css class
     *
     * sub <template></template> elements are not bound, so elemnts like <iron-list> of polymer also work
     *
     * use repeat:nameOfItem=[[enumerableExpression]] on a Template Element to repeate it for every instance of the enumarable
     * ==> this could also be nested
     *
     */
    protected _bindingsParse(node?: Node, removeAttributes?: boolean, host?: any, context?: any): void;
    private _bindingsInternalParse;
    private _bindingRunEval;
    private _bindingRunEvalInt;
    private _bindingRepeat;
    private _bindingSetNodeValue;
    private _bindingSetElementCssValue;
    private _bindingSetElementClass;
    protected _bindingsRefresh(property?: string): void;
    protected _bindingsSetValue(obj: any, path: string, value: any): void;
    private static _propertiesDictionary;
    protected _parseAttributesToProperties(): void;
    protected _waitForChildrenReady(): Promise<void>;
    protected _rootDocumentFragment: DocumentFragment;
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentLazyAppend extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentConstructorAppend extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export declare class BaseCustomWebComponentConstructorAppendLazyReady extends BaseCustomWebComponentNoAttachedTemplate {
    constructor(template?: HTMLTemplateElement, style?: CSSStyleSheet);
}
export {};
